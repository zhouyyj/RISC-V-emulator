#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>

#include <stdint.h>

void resetIO();

void decodePuts(char* str);

void termPuts(char* str);

void updateReg(uint32_t pc, uint32_t reg[32]);

void updateCharBuf();

int readKeys();
void updateLEDs();
int readSwitches();

// Include file storing elf in char array.
unsigned char rvelf[] = {
  0x7f, 0x45, 0x4c, 0x46, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0xf3, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x00, 0x02, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0xa8, 0x04, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x34, 0x00, 0x20, 0x00, 0x02, 0x00, 0x28, 0x00,
  0x06, 0x00, 0x05, 0x00, 0x03, 0x00, 0x00, 0x70, 0x3c, 0x04, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x3c, 0x04, 0x00, 0x00, 0x3c, 0x04, 0x00, 0x00,
  0x05, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xf1, 0x0f, 0x00,
  0x13, 0x01, 0x01, 0xe0, 0x73, 0x00, 0x10, 0x00, 0xef, 0x00, 0x00, 0x01,
  0x93, 0x05, 0x05, 0x00, 0x13, 0x05, 0x00, 0x00, 0x73, 0x00, 0x00, 0x00,
  0x13, 0x01, 0x01, 0xfa, 0x23, 0x2e, 0x11, 0x04, 0x23, 0x2c, 0x81, 0x04,
  0x13, 0x04, 0x01, 0x06, 0x93, 0x07, 0xc0, 0x40, 0x03, 0xa8, 0x07, 0x00,
  0x03, 0xa5, 0x47, 0x00, 0x83, 0xa5, 0x87, 0x00, 0x03, 0xa6, 0xc7, 0x00,
  0x83, 0xa6, 0x07, 0x01, 0x03, 0xa7, 0x47, 0x01, 0x23, 0x20, 0x04, 0xfd,
  0x23, 0x22, 0xa4, 0xfc, 0x23, 0x24, 0xb4, 0xfc, 0x23, 0x26, 0xc4, 0xfc,
  0x23, 0x28, 0xd4, 0xfc, 0x23, 0x2a, 0xe4, 0xfc, 0x03, 0xd7, 0x87, 0x01,
  0x23, 0x1c, 0xe4, 0xfc, 0x83, 0xc7, 0xa7, 0x01, 0x23, 0x0d, 0xf4, 0xfc,
  0x93, 0x07, 0x04, 0xfc, 0x13, 0x85, 0x07, 0x00, 0xef, 0x00, 0x00, 0x13,
  0xef, 0x00, 0xc0, 0x15, 0x23, 0x20, 0xa4, 0xfe, 0x93, 0x07, 0x80, 0x42,
  0x83, 0xa5, 0x07, 0x00, 0x03, 0xa6, 0x47, 0x00, 0x83, 0xa6, 0x87, 0x00,
  0x03, 0xa7, 0xc7, 0x00, 0x83, 0xa7, 0x07, 0x01, 0x23, 0x26, 0xb4, 0xfa,
  0x23, 0x28, 0xc4, 0xfa, 0x23, 0x2a, 0xd4, 0xfa, 0x23, 0x2c, 0xe4, 0xfa,
  0x23, 0x2e, 0xf4, 0xfa, 0x93, 0x07, 0xc4, 0xfa, 0x13, 0x85, 0x07, 0x00,
  0xef, 0x00, 0x00, 0x0f, 0x83, 0x27, 0x04, 0xfe, 0x63, 0x96, 0x07, 0x00,
  0x93, 0x07, 0x00, 0x00, 0x6f, 0x00, 0xc0, 0x09, 0x13, 0x05, 0x10, 0x00,
  0xef, 0x00, 0x80, 0x0a, 0x03, 0x27, 0x04, 0xfe, 0x93, 0x07, 0x10, 0x00,
  0x63, 0x16, 0xf7, 0x00, 0x93, 0x07, 0x00, 0x00, 0x6f, 0x00, 0x00, 0x08,
  0x13, 0x05, 0x10, 0x00, 0xef, 0x00, 0xc0, 0x08, 0x03, 0x27, 0x04, 0xfe,
  0x93, 0x07, 0x20, 0x00, 0x63, 0x16, 0xf7, 0x00, 0x93, 0x07, 0x00, 0x00,
  0x6f, 0x00, 0x40, 0x06, 0x93, 0x07, 0x10, 0x00, 0x23, 0x26, 0xf4, 0xfe,
  0x93, 0x07, 0x10, 0x00, 0x23, 0x24, 0xf4, 0xfe, 0x93, 0x07, 0x20, 0x00,
  0x23, 0x22, 0xf4, 0xfe, 0x6f, 0x00, 0x80, 0x03, 0x03, 0x27, 0xc4, 0xfe,
  0x83, 0x27, 0x84, 0xfe, 0xb3, 0x07, 0xf7, 0x00, 0x23, 0x2e, 0xf4, 0xfc,
  0x03, 0x25, 0xc4, 0xfd, 0xef, 0x00, 0x40, 0x04, 0x83, 0x27, 0x84, 0xfe,
  0x23, 0x26, 0xf4, 0xfe, 0x83, 0x27, 0xc4, 0xfd, 0x23, 0x24, 0xf4, 0xfe,
  0x83, 0x27, 0x44, 0xfe, 0x93, 0x87, 0x17, 0x00, 0x23, 0x22, 0xf4, 0xfe,
  0x03, 0x27, 0x44, 0xfe, 0x83, 0x27, 0x04, 0xfe, 0xe3, 0x42, 0xf7, 0xfc,
  0x93, 0x07, 0x00, 0x00, 0x13, 0x85, 0x07, 0x00, 0x83, 0x20, 0xc1, 0x05,
  0x03, 0x24, 0x81, 0x05, 0x13, 0x01, 0x01, 0x06, 0x67, 0x80, 0x00, 0x00,
  0x13, 0x01, 0x01, 0xfe, 0x23, 0x2e, 0x81, 0x00, 0x13, 0x04, 0x01, 0x02,
  0x23, 0x26, 0xa4, 0xfe, 0x83, 0x27, 0xc4, 0xfe, 0x13, 0x05, 0x40, 0x06,
  0x93, 0x85, 0x07, 0x00, 0x73, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00,
  0x03, 0x24, 0xc1, 0x01, 0x13, 0x01, 0x01, 0x02, 0x67, 0x80, 0x00, 0x00,
  0x13, 0x01, 0x01, 0xfe, 0x23, 0x2e, 0x81, 0x00, 0x13, 0x04, 0x01, 0x02,
  0x23, 0x26, 0xa4, 0xfe, 0x83, 0x27, 0xc4, 0xfe, 0x13, 0x05, 0x50, 0x06,
  0x93, 0x85, 0x07, 0x00, 0x73, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00,
  0x03, 0x24, 0xc1, 0x01, 0x13, 0x01, 0x01, 0x02, 0x67, 0x80, 0x00, 0x00,
  0x13, 0x01, 0x01, 0xfe, 0x23, 0x2e, 0x81, 0x00, 0x13, 0x04, 0x01, 0x02,
  0x73, 0x00, 0x10, 0x00, 0x13, 0x05, 0x80, 0x0c, 0x73, 0x00, 0x00, 0x00,
  0x93, 0x07, 0x05, 0x00, 0x23, 0x26, 0xf4, 0xfe, 0x83, 0x27, 0xc4, 0xfe,
  0x13, 0x85, 0x07, 0x00, 0x03, 0x24, 0xc1, 0x01, 0x13, 0x01, 0x01, 0x02,
  0x67, 0x80, 0x00, 0x00, 0x45, 0x6e, 0x74, 0x65, 0x72, 0x20, 0x74, 0x68,
  0x65, 0x20, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x20, 0x6f, 0x66, 0x20,
  0x74, 0x65, 0x72, 0x6d, 0x73, 0x3a, 0x00, 0x00, 0x46, 0x69, 0x62, 0x6f,
  0x6e, 0x61, 0x63, 0x63, 0x69, 0x20, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6e,
  0x63, 0x65, 0x3a, 0x00, 0x41, 0x1b, 0x00, 0x00, 0x00, 0x72, 0x69, 0x73,
  0x63, 0x76, 0x00, 0x01, 0x11, 0x00, 0x00, 0x00, 0x04, 0x10, 0x05, 0x72,
  0x76, 0x33, 0x32, 0x69, 0x32, 0x70, 0x30, 0x00, 0x47, 0x43, 0x43, 0x3a,
  0x20, 0x28, 0x67, 0x31, 0x65, 0x61, 0x39, 0x37, 0x38, 0x65, 0x33, 0x30,
  0x36, 0x36, 0x29, 0x20, 0x31, 0x32, 0x2e, 0x31, 0x2e, 0x30, 0x00, 0x00,
  0x2e, 0x73, 0x68, 0x73, 0x74, 0x72, 0x74, 0x61, 0x62, 0x00, 0x2e, 0x74,
  0x65, 0x78, 0x74, 0x00, 0x2e, 0x72, 0x6f, 0x64, 0x61, 0x74, 0x61, 0x00,
  0x2e, 0x72, 0x69, 0x73, 0x63, 0x76, 0x2e, 0x61, 0x74, 0x74, 0x72, 0x69,
  0x62, 0x75, 0x74, 0x65, 0x73, 0x00, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x65,
  0x6e, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
  0x00, 0x02, 0x00, 0x00, 0x0c, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x11, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
  0x0c, 0x04, 0x00, 0x00, 0x0c, 0x04, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x70,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x04, 0x00, 0x00,
  0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x58, 0x04, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x73, 0x04, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00
};
unsigned int rvelf_len = 1432;

#define ELF_ARR rvelf
#define ELF_ARR_LEN rvelf_len

// Memory layout.
#define MEM_START 0x0
#define MEM_SIZE 0x100000  // 1MiB
#define IO_START 0x100000
#define IO_SIZE 0xFFF      // 4KiB
uint8_t memory[MEM_SIZE + IO_SIZE];

// Convert memory to target data width.
#define MEM_WORD_U(addr) *(uint32_t *)&memory[addr]
#define MEM_HALF_U(addr) *(uint16_t *)&memory[addr]
#define MEM_BYTE_U(addr) *(uint8_t *)&memory[addr]
#define MEM_WORD_S(addr) *(int32_t *)&memory[addr]
#define MEM_HALF_S(addr) *(int16_t *)&memory[addr]
#define MEM_BYTE_S(addr) *(int8_t *)&memory[addr]

// Register ABI Names.
enum RegName {
  _zero = 0,  // Hard-wired zero
  _ra,  // Return address
  _sp, _gp, _tp,  // Stack, Global, Thread pointer
  _t0,  // Temporary / alternate link register
  _t1, _t2,  // Temporaries
  _s0, _fp = _s0,  // Saved register / frame pointer 
  _s1,  // Saved register
  _a0, _a1,  // Function arguments / return values
  _a2, _a3, _a4, _a5, _a6, _a7,  // Function arguments
  _s2, _s3, _s4, _s5, _s6, _s7, _s8, _s9, _s10, _s11,  // Saved registers
  _t3, _t4, _t5, _t6,  // Temporaries
  REG_NUM
};

// Registers.
uint32_t reg[REG_NUM] = {0};
uint32_t pc = 0;

// ELF header.
#define ELFMAG_W0 0x464C457F /* 7F E L F */
#define ELFMAG_W4 0x00010101 /* 32-bit, LSB, SysV ABI */
#define ET_EXEC 2            /* Executable file */
#define EM_RISCV 243         /* RISC-V */
typedef struct {
  uint8_t e_ident[16]; /* Magic number and other info */
  uint16_t e_type;     /* Object file type */
  uint16_t e_machine;  /* Architecture */
  uint32_t e_version;  /* Object file version */
  uint32_t e_entry;    /* Entry point virtual address */
} Elf32_Ehdr;

// Load elf from array.
int load() {
  char msg[40] = {0};
  // Check ELF size.
  if (ELF_ARR_LEN >= MEM_SIZE || ELF_ARR_LEN <= 52) {
    sprintf(msg, "load: ELF bad size");
    termPuts(msg);
    return 1;
  }
  // Load ELF.
  memcpy(memory, ELF_ARR, ELF_ARR_LEN);
  Elf32_Ehdr *elf_h = (Elf32_Ehdr *)memory;

  // Check ELF header.
  int ret_val = 0;
  ret_val |= MEM_WORD_U(0) != ELFMAG_W0 || MEM_WORD_U(4) != ELFMAG_W4;
  ret_val |= elf_h->e_type != ET_EXEC;
  ret_val |= elf_h->e_machine != EM_RISCV;

  if (ret_val) {
    sprintf(msg, "load: ELF bad header");
  } else {
    pc = elf_h->e_entry; // Set pc to entry point.
    sprintf(msg, "load: entry point address 0x%x", pc);
  }
  termPuts(msg);
  return ret_val;
}

// Instruction types.
#define OPCODE(inst) inst&0b1111111
typedef struct {
  uint32_t opcode : 7, rd : 5, funct3 : 3, rs1 : 5, rs2 : 5, funct7 : 7;
} R_Inst;
typedef struct {
  uint32_t opcode : 7, rd : 5, funct3 : 3, rs1 : 5, imm11_0 : 12;
} I_Inst_u;
typedef struct {
  uint32_t opcode : 7, rd : 5, funct3 : 3, rs1 : 5;
  int32_t imm11_0 : 12;
} I_Inst_s;
typedef struct {
  uint32_t opcode : 7, imm4_0 : 5, funct3 : 3, rs1 : 5, rs2 : 5;
  int32_t imm11_5 : 7;
} S_Inst;
typedef struct {
  uint32_t opcode : 7, imm11 : 1, imm4_1 : 4, funct3 : 3, rs1 : 5, rs2 : 5,
           imm10_5 : 6, imm12 : 1;
} B_Inst;
typedef struct {
  uint32_t opcode : 7, rd : 5, imm31_12 : 20;
} U_Inst;
typedef struct {
  uint32_t opcode : 7, rd : 5, imm19_12 : 8, imm11 : 1, imm10_1 : 10, imm20 : 1;
} J_Inst;
typedef union {
  R_Inst R;
  I_Inst_u Iu;
  I_Inst_s Is;
  S_Inst S;
  B_Inst B;
  U_Inst U;
  J_Inst J;
} InstField;

typedef enum OpcodeVal {
  U_LUI     = 0b0110111,
  U_AUIPC   = 0b0010111,
  J_JAL     = 0b1101111,
  Is_JALR   = 0b1100111,
  B_Branch  = 0b1100011, // Branch.
  I_Load    = 0b0000011, // Load.
  S_Store   = 0b0100011, // Store.
  I_OpImm   = 0b0010011, // Immediate computation.
  R_Op      = 0b0110011, // Register computation.
  I_MiscMem = 0b0001111, // FENCE (unimplemented).
  Iu_System  = 0b1110011  // ECALL & EBREAK.
} Opcode_T;

bool f_pause = false;
bool f_step = false;
bool f_ecall = false;
bool f_exit = false;

void handleEcall(){
  f_ecall = false;
  char term_str[40] = {'\0'};
  switch (reg[_a0]) {
    case 0:  // exit (status code)
      f_exit = true;
      sprintf(term_str, "exit with code %d", reg[_a1]);
      break;
    case 100:  // print (signed decimal)
      sprintf(term_str, ">> %d", reg[_a1]);
      break;
    case 101:  // print (null-terminated char*)
      sprintf(term_str, ">> %.36s", (char *)&memory[reg[_a1]]);
      break;
    // case 102:  // print to seven-segment displays
    //   break;
    case 103:  // print regs to terminal (not VGA)
      printf("\nRegisters\n");
      for (int i = 0; i < REG_NUM; ++i) {
        printf("x%-2d 0x%08x  ", i, reg[i]);
        if (i % 4 == 3) printf("\n");
      }
      printf("\n");
      sprintf(term_str, "Registers printed to terminal.");
      break;
    case 200:  // read int from switches
      reg[_a0] = readSwitches();
      sprintf(term_str, "<< %d", reg[_a0]);
      break;
    case 243:
      break;
    default:
      sprintf(term_str, "%d: unknown ecall\n", reg[_a0]);
      break;
  }
  termPuts(term_str);
}

void handleBranch(InstField *inst, char *out_op) {
  uint32_t tgt = pc + ((-inst->B.imm12 << 12) | (inst->B.imm11 << 11) |
                 (inst->B.imm10_5 << 5) | (inst->B.imm4_1 << 1)) - 4;
  switch (inst->B.funct3) {
    case 0b000:  // BEQ
      if (reg[inst->R.rs1] == reg[inst->R.rs2]) pc = tgt;
      sprintf(out_op, "beq x%d, x%d, 0x%x", inst->B.rs1, inst->B.rs2, tgt);
      break;
    case 0b001:  // BNE
      if (reg[inst->R.rs1] != reg[inst->R.rs2]) pc = tgt;
      sprintf(out_op, "bne x%d, x%d, 0x%x", inst->B.rs1, inst->B.rs2, tgt);
      break;
    case 0b100:  // BLT
      if ((int32_t)reg[inst->R.rs1] < (int32_t)reg[inst->R.rs2]) pc = tgt;
      sprintf(out_op, "blt x%d, x%d, 0x%x", inst->B.rs1, inst->B.rs2, tgt);
      break;
    case 0b101:  // BGE
      if ((int32_t)reg[inst->R.rs1] >= (int32_t)reg[inst->R.rs2]) pc = tgt;
      sprintf(out_op, "bge x%d, x%d, 0x%x", inst->B.rs1, inst->B.rs2, tgt);
      break;
    case 0b110:  // BLTU
      if (reg[inst->R.rs1] < reg[inst->R.rs2]) pc = tgt;
      sprintf(out_op, "bltu x%d, x%d, 0x%x", inst->B.rs1, inst->B.rs2, tgt);
      break;
    case 0b111:  // BGEU
      if (reg[inst->R.rs1] >= reg[inst->R.rs2]) pc = tgt;
      sprintf(out_op, "bgeu x%d, x%d, 0x%x", inst->B.rs1, inst->B.rs2, tgt);
      break;
  }
}

void handleLoad(InstField *inst, char *out_op) {
  uint32_t addr = reg[inst->Is.rs1] + inst->Is.imm11_0;
  switch (inst->Is.funct3) {
    case 0b000: // LB
      reg[inst->Is.rd] = MEM_BYTE_S(addr);
      sprintf(out_op, "lb x%d, %d(x%d)", inst->Is.rd, inst->Is.imm11_0, inst->Is.rs1);
      break;
    case 0b001: // LH
      reg[inst->Is.rd] = MEM_HALF_S(addr);
      sprintf(out_op, "lh x%d, %d(x%d)", inst->Is.rd, inst->Is.imm11_0, inst->Is.rs1);
      break;
    case 0b010: // LW
      reg[inst->Is.rd] = MEM_WORD_S(addr);
      sprintf(out_op, "lw x%d, %d(x%d)", inst->Is.rd, inst->Is.imm11_0, inst->Is.rs1);
      break;
    case 0b100: // LBU
      reg[inst->Is.rd] = MEM_BYTE_U(addr);
      sprintf(out_op, "lbu x%d, %d(x%d)", inst->Is.rd, inst->Is.imm11_0, inst->Is.rs1);
      break;
    case 0b101: // LHU
      reg[inst->Is.rd] = MEM_HALF_U(addr);
      sprintf(out_op, "lhu x%d, %d(x%d)", inst->Is.rd, inst->Is.imm11_0, inst->Is.rs1);
      break;
    default:
      sprintf(out_op, "unknown load");
      break;
  }
}

void handleStore(InstField *inst, char *out_op) {
  int32_t offset = inst->S.imm4_0 + (inst->S.imm11_5 << 5);
  uint32_t addr = reg[inst->S.rs1] + offset;
  switch (inst->S.funct3) {
    case 0b000: // SB
      MEM_BYTE_S(addr) = reg[inst->S.rs2];
      sprintf(out_op, "sb x%d, %d(x%d)", inst->S.rs2, offset, inst->Is.rs1);
      break;
    case 0b001: // SH
      MEM_HALF_S(addr) = reg[inst->S.rs2];
      sprintf(out_op, "sh x%d, %d(x%d)", inst->S.rs2, offset, inst->Is.rs1);
      break;
    case 0b010: // SW
      MEM_WORD_S(addr) = reg[inst->S.rs2];
      sprintf(out_op, "sw x%d, %d(x%d)", inst->S.rs2, offset, inst->Is.rs1);
      break;
    default:
      sprintf(out_op, "unknown load");
      break;
  }
}

void handleOp(InstField *inst, char *out_op) {
  switch (inst->R.funct3) {
    case 0b000:  // ADD / SUB
      if (inst->R.funct7 == 0) {  // ADD
        reg[inst->R.rd] = reg[inst->R.rs1] + reg[inst->R.rs2];
        sprintf(out_op, "add x%d, x%d, x%d", inst->R.rd, inst->R.rs1, inst->R.rs2);
      } else {  // SUB
        reg[inst->R.rd] = reg[inst->R.rs1] - reg[inst->R.rs2];
        sprintf(out_op, "sub x%d, x%d, x%d", inst->R.rd, inst->R.rs1, inst->R.rs2);
      }
      break;
    case 0b001:  // SLL
      reg[inst->R.rd] = reg[inst->R.rs1] << (0b11111 & reg[inst->R.rs2]);
      sprintf(out_op, "sll x%d, x%d, x%d", inst->R.rd, inst->R.rs1, inst->R.rs2);
      break;
    case 0b010:  // SLT: SLT and SLTU perform signed and unsigned compares
                 // respectively, writing 1 to rd if rs1 < rs2, 0 otherwise.
      reg[inst->R.rd] = ((int32_t)reg[inst->R.rs1] < (int32_t)reg[inst->R.rs2]);
      sprintf(out_op, "slt x%d, x%d, x%d", inst->R.rd, inst->R.rs1, inst->R.rs2);
      break;
    case 0b011:  // SLTU
      reg[inst->R.rd] = (reg[inst->R.rs1] < reg[inst->R.rs2]);
      sprintf(out_op, "sltu x%d, x%d, x%d", inst->R.rd, inst->R.rs1, inst->R.rs2);
      break;
    case 0b100:  // XOR
      reg[inst->R.rd] = reg[inst->R.rs1] ^ reg[inst->R.rs2];
      sprintf(out_op, "xor x%d, x%d, x%d", inst->R.rd, inst->R.rs1, inst->R.rs2);
      break;
    case 0b101:  // SRL / SRA
      if (inst->R.funct7 == 0) {  // SRL
        reg[inst->R.rd] = (uint32_t)reg[inst->R.rs1] >> (0b11111 & reg[inst->R.rs2]);
        sprintf(out_op, "srl x%d, x%d, x%d", inst->R.rd, inst->R.rs1, inst->R.rs2);
      } else {  // SRA
        reg[inst->R.rd] = (int32_t)reg[inst->R.rs1] >> (0b11111 & reg[inst->R.rs2]);
        sprintf(out_op, "sra x%d, x%d, x%d", inst->R.rd, inst->R.rs1, inst->R.rs2);
      }
      break;
    case 0b110:  // OR
      reg[inst->R.rd] = reg[inst->R.rs1] | reg[inst->R.rs2];
      sprintf(out_op, "or x%d, x%d, x%d", inst->R.rd, inst->R.rs1, inst->R.rs2);
      break;
    case 0b111:  // AND
      reg[inst->R.rd] = reg[inst->R.rs1] & reg[inst->R.rs2];
      sprintf(out_op, "and x%d, x%d, x%d", inst->R.rd, inst->R.rs1, inst->R.rs2);
      break;
    default:
      sprintf(out_op, "unknown op");
      break;
  }
}

void handleOpImm(InstField *inst, char* out_op) {
  sprintf(out_op, "opimm");
  switch (inst->Is.funct3) {
    case 0b000:  // ADDI
      reg[inst->Is.rd] = (int32_t)reg[inst->Is.rs1] + inst->Is.imm11_0;
      sprintf(out_op, "addi x%d, x%d, %d", inst->Is.rd, inst->Is.rs1, inst->Is.imm11_0);
      break;
    case 0b010:  // SLTI
      reg[inst->Is.rd] = (int32_t)reg[inst->Is.rs1] < inst->Is.imm11_0;
      sprintf(out_op, "slti x%d, x%d, %d", inst->Is.rd, inst->Is.rs1, inst->Is.imm11_0);
      break;
    case 0b011:  // SLTIU
      reg[inst->Is.rd] = reg[inst->Is.rs1] < (uint32_t)inst->Is.imm11_0;
      sprintf(out_op, "sltiu x%d, x%d, %d", inst->Is.rd, inst->Is.rs1, inst->Is.imm11_0);
      break;
    case 0b100:  // XORI
      reg[inst->Is.rd] = reg[inst->Is.rs1] ^ inst->Is.imm11_0;
      sprintf(out_op, "xori x%d, x%d, %d", inst->Is.rd, inst->Is.rs1, inst->Is.imm11_0);
      break;
    case 0b110:  // ORI
      reg[inst->Is.rd] = reg[inst->Is.rs1] | inst->Is.imm11_0;
      sprintf(out_op, "ori x%d, x%d, %d", inst->Is.rd, inst->Is.rs1, inst->Is.imm11_0);
      break;
    case 0b111:  // ANDI
      reg[inst->Is.rd] = reg[inst->Is.rs1] & inst->Is.imm11_0;
      sprintf(out_op, "andi x%d, x%d, %d", inst->Is.rd, inst->Is.rs1, inst->Is.imm11_0);
      break;
    case 0b001:  // SLLI
      // unsigned int shamt = inst->R.rs2;
      reg[inst->R.rd] = reg[inst->R.rs1] << inst->R.rs2;
      sprintf(out_op, "slli x%d, x%d, %u", inst->R.rd, inst->R.rs1, inst->R.rs2);
      break;
    case 0b101:  // SRLI / SRAI
      // unsigned int shamt = inst->R.rs2;
      if (inst->R.funct7 == 0) {  // SRLI
        reg[inst->Is.rd] = (uint32_t)reg[inst->R.rs1] >> inst->R.rs2;
        sprintf(out_op, "srli x%d, x%d, %u", inst->R.rd, inst->R.rs1, inst->R.rs2);
      } else {  // SRAI
        reg[inst->Is.rd] = (int32_t)reg[inst->R.rs1] >> inst->R.rs2;
        sprintf(out_op, "slai x%d, x%d, %u", inst->R.rd, inst->R.rs1, inst->R.rs2);
      }
      break;
    default:
      sprintf(out_op, "unknown op-imm");
      break;
  }
}

// #define QUIT_N(n) { printf("quit %d\n", n); return n; }

int main() {
reset:
  resetIO();
  f_pause = f_step = f_ecall = f_exit = false;

  // Load ELF into memory.
  if (load()) return 1;

  // Initialize output.
  char out_str[40] = {0};
  char* out_op = out_str + 18;
  sprintf(out_str, "Addr    Inst      Disassembly");
  decodePuts(out_str);
  updateCharBuf();

  while (true) {
    updateLEDs();

    // Check pause/continue, step, reset.
    int keys = readKeys();
    if (keys & 0b1000) goto reset;
    if (f_exit) continue;
    if (keys & 0b10) {
      f_pause = !f_pause;
      if (f_pause) sprintf(out_str, "paused at 0x%-8x", pc);
      else sprintf(out_str, "continue from 0x%-8x", pc);
      termPuts(out_str);
      updateCharBuf();
    }
    if (keys & 0b1) f_step = true;
    if (f_step) {
      f_step = false;
      sprintf(out_str, "step to 0x%-8x", pc);
      termPuts(out_str);
    } else if (f_pause)
      continue;

    if (pc >= MEM_SIZE) {
      f_exit = true;
      sprintf(out_str, "pc=0x%d out of memory bound", pc);
      termPuts(out_str);
      updateCharBuf();
      continue;
    }
    // Fetch new instruction and update pc.
    uint32_t inst_u32 = MEM_WORD_U(pc);
    sprintf(out_str, "%-8x%08x  ", pc, inst_u32);
    pc += 4;

    // Decode new instruction.
    InstField *inst = (InstField *)&inst_u32;
    switch (OPCODE(inst_u32)) {
      case U_LUI:
        reg[inst->U.rd] = inst->U.imm31_12 << 12;
        sprintf(out_op, "lui x%d, 0x%x", inst->U.rd, inst->U.imm31_12);
        break;
      case U_AUIPC:
        reg[inst->U.rd] = pc - 4 + (inst->U.imm31_12 << 12);
        sprintf(out_op, "auipc x%d, 0x%x", inst->U.rd, inst->U.imm31_12);
        break;
      case J_JAL:
        reg[inst->J.rd] = pc;
        pc += ((-inst->J.imm20 << 20) | (inst->J.imm19_12 << 12) |
               (inst->J.imm11 << 11) | (inst->J.imm10_1 << 1)) - 4;
        sprintf(out_op, "jal x%d, 0x%x", inst->J.rd, pc);
        break;
      case Is_JALR:
        reg[inst->Is.rd] = pc;
        pc = (-2) & (reg[inst->Is.rs1] + inst->Is.imm11_0);
        sprintf(out_op, "jalr x%d, x%d, %d",
               inst->Is.rd, inst->Is.rs1, inst->Is.imm11_0);
        break;
      case B_Branch:
        handleBranch(inst, out_op);
        break;
      case I_Load:
        handleLoad(inst, out_op);
        break;
      case S_Store:
        handleStore(inst, out_op);
        break;
      case I_OpImm:
        handleOpImm(inst, out_op);
        break;
      case R_Op:
        handleOp(inst, out_op);
         break;
      case I_MiscMem:
        sprintf(out_op, "unsupported misc-mem");
        break;
      case Iu_System:
        if (inst->Iu.imm11_0 == 0x0) {
          sprintf(out_op, "ecall (%d)", reg[_a0]);
          f_ecall = true;
        } else {
          sprintf(out_op, "ebreak");
          f_pause = true;
        }
        break;
      default:
        sprintf(out_op, "unknown");
        break;
    }

    reg[_zero] = 0; // Reset x0 (hard zero).
    // Update outputs.
    decodePuts(out_str);
    updateReg(pc, reg);
    if (f_ecall) handleEcall();  // Deal with ecalls.
    updateCharBuf();
  }
  return 1; // Terminate if pc out of memory bound.
}
#include <stdio.h>
#include <string.h>

#ifdef __NIOS2__
#define PB_EDGECAPTURE ((volatile int *)0xFF20005C)
#define SWITCHES ((volatile int *)0xFF200040)
#define RLEDs ((volatile int *)0xFF200000)

#define CHAR_W 80
#define CHAR_H 30
#define DECODE_W 40
#define TERM_W 40
#define TERM_H 21

char char_buf[CHAR_H][CHAR_W];
int row_count_l = 0;
int row_count_r = 0;

/* set a single pixel on the screen at x,y
 * x in [0,319], y in [0,239], and colour in [0,65535]
 */
void write_pixel(int x, int y, short colour) {
  volatile short *vga_addr =
      (volatile short *)(0x08000000 + (y << 10) + (x << 1));
  *vga_addr = colour;
}
/* write a single character to the character buffer at x,y
 * x in [0,79], y in [0,59]
 */
void write_char(int x, int y, char c) {
  // VGA character buffer
  volatile char *character_buffer = (char *)(0x09000000 + (y << 7) + x);
  *character_buffer = c;
}
/* use write_pixel to set entire screen to black (does not clear the character
 * buffer) */
void clear_screen() {
  int x, y;
  for (x = 0; x < 320; x++) {
    for (y = 0; y < 240; y++) {
      write_pixel(x, y, 0);
    }
  }

  row_count_l = 0;
  row_count_r = 0;
  for (int i = 0; i < CHAR_H; ++i) {
    for (int j = 0; j < CHAR_W; ++j) {
      char_buf[i][j] = 0;
      write_char(j, i*2, 0);
      write_char(j, i*2+1, 0);
    }
  }
}
#endif

void updateCharBuf() {
#ifdef __NIOS2__
  for (int i = 0; i < CHAR_H; ++i) {
    for (int j = 0; j < CHAR_W; ++j) {
      write_char(j, i*2, char_buf[i][j]);
    }
  }
#endif
}

void resetIO(){
#ifdef __NIOS2__
  clear_screen();
  *PB_EDGECAPTURE = -1;
#endif
}

// void clearTerm(){
// #ifdef __NIOS2__
//   row_count_r = 0;
//   for (int i = 0; i < TERM_H-1; ++i) {
//     for (int j = DECODE_W; j < CHAR_W-1; ++j) {
//       char_buf[i][j] = 0;
//     }
//   }
//   updateCharBuf();
// #endif
// }

void decodePuts(char* str) {
#ifdef __NIOS2__
  if (row_count_l < TERM_H - 1) {
    row_count_l += 1;
  } else {
    for (int i = 1; i < TERM_H-1; ++i){
      memcpy(&char_buf[i], &char_buf[i + 1], DECODE_W);
    }
  }
  char_buf[row_count_l-1][0] = '\0';
  strncat((char *)&char_buf[row_count_l-1], str, DECODE_W - 1);
#endif
  puts(str);
}

void termPuts(char* str) {
  #ifdef __NIOS2__
  if (row_count_r < TERM_H - 1) {
    row_count_r += 1;
  } else {
    for (int i = 0; i < TERM_H - 1; ++i) {
      memcpy(&char_buf[i][DECODE_W], &char_buf[i + 1][DECODE_W], TERM_W);
    }
  }
  char_buf[row_count_r-1][DECODE_W] = '\0';
  strncat((char *)&char_buf[row_count_r-1]+DECODE_W, str, TERM_W - 1);
#endif
  puts(str);
}

void updateReg(uint32_t pc, uint32_t reg[32]) {
#ifdef __NIOS2__
  sprintf(&char_buf[TERM_H][0], "pc  %08x", pc);
  sprintf(&char_buf[TERM_H][20], "Reg Value");
  sprintf(&char_buf[TERM_H][40], "Reg Value");
  sprintf(&char_buf[TERM_H][60], "Reg Value");
  for (int i = 0; i < 8; ++i) {
    sprintf(&char_buf[TERM_H+1+i][0], "x%-2d %08x", i*4, reg[i*4]);
    sprintf(&char_buf[TERM_H+1+i][20], "x%-2d %08x", i*4+1, reg[i*4+1]);
    sprintf(&char_buf[TERM_H+1+i][40], "x%-2d %08x", i*4+2, reg[i*4+2]);
    sprintf(&char_buf[TERM_H+1+i][60], "x%-2d %08x", i*4+3, reg[i*4+3]);
  }
#endif
}

int readKeys(){
#ifdef __NIOS2__
  int PBreleases = *PB_EDGECAPTURE;
  *PB_EDGECAPTURE = -1;
  return PBreleases;
#endif
  return 0;
}

void updateLEDs() {
#ifdef __NIOS2__
  *RLEDs = *SWITCHES;
#endif
}

int readSwitches() {
#ifdef __NIOS2__
  return *SWITCHES;
#endif
}

// #ifdef __NIOS2__
// #define CTRL_D 4
// #else
// #define CTRL_D EOF
// #endif

// #ifdef __NIOS2__
//   clear_screen();
//   int ln = 0;
// #endif

// #ifdef __NIOS2__
//     snprintf(&char_buf[ln], 40, "%-8x0x%08x    ", pc, inst_u32);
//     updateCharBuf();
//     if (ln < CHAR_H-1) ln+=2;
// #endif
